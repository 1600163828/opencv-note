
>http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html


#### 本节目标
```
这一次，我们了解了轮廓的层次结构，即轮廓中的父子关系。
```

#### 原理

在过去几篇关于轮廓的文章中，我们研究了与OpenCV提供的轮廓相关的几个函数。但是当我们发现图像中的轮廓使用cv2.findContours()函数，我们通过一个参数，Contour Retrieval Mode(轮廓检索模式),cv2.RETR_TREE和它的工作很好。但它究竟意味着什么呢？

此外，在输出，我们得到了三个数组，第一个是图像，第二个是我们的轮廓，和一个输出，我们命名为层次结构（请检查代码在以前的文章）。但我们从来没有使用这个层次。那么这个层次又是什么呢？它与前面提到的函数参数有什么关系？

这就是我们要处理的这篇文章。


#### 什么是层次结构？

通常，我们使用函数cv2.findContours()去检测图像中的对象，有时对象在不同的位置。但在某些情况下，一些形状是在其他形状。就像嵌套的数字。在这种情况下，我们称外一个为父，内为子。这样，图像中的轮廓之间有一定的关系。我们可以指定一个轮廓是如何相互连接的，比如，它是其他轮廓的子，还是它的父等。这种关系的表示称为层次结构。

考虑下面的一个例子图像：

```
|---------------|
| |----|        | 
| |    |        |
| |----|        |
|---------------|
```

在这幅图像中，有几个形状，表示最外层框的外部和内部轮廓。

在这里，分别是外部或外轮廓。我们可以说，他们是在hierarchy-0或只是他们在同一个层次。

我提到了这些东西来理解相同的层次层次，外部轮廓，儿童轮廓，父轮廓，第一个子层次等，现在让我们进入OpenCV。


#### OpenCV的层次表示

因此，每个轮廓都有自己的信息，它是什么层次，谁是它的子层次，谁是它的父层次等, OpenCV将它表示为四个值的数组 
[Next, Previous, First_Child, Parent]

下一个表示同一层次的下一个轮廓。

例如，在我们采取contour-0图片。谁是下一个轮廓在同一水平？这是contour-1。所以简单地把下一个= 1。同样的contour-1，其次是contour-2。所以下一个= 2。

以前表示在相同的层次上的前轮廓。

同上。以前的contour-1轮廓contour-0在同一水平。同样的contour-2，它是contour-1。和contour-0，以前没有，所以把它作为1。

first_child表示其第一个子层次的轮廓

父层次denotes指数of its父层次轮廓

如果没有子或父，则将该字段作为- 1

因此，现在我们了解了OpenCV中使用的层次结构样式，我们可以在上面给出的相同图像的帮助下检查OpenCV的轮廓检索模式。


#### 轮廓检索模式

##### 1. RETR_LIST

这是最简单的四旗（从解释的角度来看）。它只是检索所有的轮廓，但不创建任何亲子关系。父母和孩子是平等的根据这条规则，他们只是轮廓。它们属于同一层次。

所以在这里，第三和第四级的层次结构数组总是- 1。但显然，下一个和以前的术语将有相应的值。只是检查自己和验证它。

下面是我得到的结果，每一行都是相应轮廓的层次细节。例如，第一行对应轮廓0。下轮廓是轮廓1。所以下一个= 1。没有以前的轮廓，所以以前= 0。剩下的两个，如前所述，它是- 1。


```
>>> hierarchy
array([[[ 1, -1, -1, -1],
        [ 2,  0, -1, -1],
        [ 3,  1, -1, -1],
        [ 4,  2, -1, -1],
        [ 5,  3, -1, -1],
        [ 6,  4, -1, -1],
        [ 7,  5, -1, -1],
        [-1,  6, -1, -1]]])
```
如果您没有使用任何层次结构特性，这是您代码中使用的好选择。

##### 2. RETR_EXTERNAL

如果使用这个标志，它只返回极端的外部标志。所有儿童轮廓都留下。我们可以说，根据这条法律，只有每个家庭中的长子才被照顾。它不关心家庭的其他成员：）。

那么，在我们的图像中，有多少极端的外部轮廓呢？即在hierarchy-0水平？只有3，即轮廓0,1,2，对吗？现在尝试使用这个标志找到轮廓。在这里，每个元素的值与上面相同。与以上结果比较。下面是我得到的：

```
>>> hierarchy
array([[[ 1, -1, -1, -1],
        [ 2,  0, -1, -1],
        [-1,  1, -1, -1]]])
```

如果只想提取外部轮廓，可以使用此标志。在某些情况下它可能是有用的。


##### 3. RETR_CCOMP

这个标志检索所有的轮廓和安排他们到一个层次结构。即外部对象的轮廓（即边界）被放置在hierarchy-1。和孔内物体的轮廓（如果有的话）放在hierarchy-2。如果它里面的任何物体，其轮廓重新放在hierarchy-1只。与孔hierarchy-2等等。

只需考虑一个黑色背景上的“大白零”图像。零的外圆属于第一层次，零的内圆属于第二层次。

我们可以用简单的图像来解释它。在这里，我已标记的顺序，在红色的轮廓和层次结构，他们属于，在绿色（1或2）。顺序是一样的顺序OpenCV检测轮廓。

所以首先考虑轮廓，即contour-0。这是hierarchy-1。它有两个孔，轮廓1和2，他们属于hierarchy-2。所以contour-0下轮廓，在相同等级的是contour-3。没有前一个。其首先是孩子hierarchy-2是contour-1。它没有父母，因为它是在hierarchy-1。因此，它的层次结构阵列是[ 3，1,1，- 1 ]


现在把contour-1。这是hierarchy-2。在下一个（同一层次的contour-1亲子关系下）是contour-2。没有以前。没有孩子，但父母是contour-0。所以数组[ 2，1 ]，-1,0。同样contour-2：它是hierarchy-2。没有未来的轮廓在同一层次下contour-0。所以没有下。以前是contour-1。没有孩子，父母是contour-0。所以数组[ -1,1，-1,0 ]。轮廓3：下hierarchy-1是contour-5。以前是contour-0。孩子和家长contour-4。所以5,0,4阵列[ 1 ]。轮廓4：它是在层次2下有没有兄弟姐妹contour-3。所以，没有未来，没有过去，没有孩子，父母是contour-3。所以数组[ - 1，- 1，- 3]。剩下的你可以填满。这是我得到的最终答案：

```
>>> hierarchy
array([[[ 3, -1,  1, -1],
        [ 2, -1, -1,  0],
        [-1,  1, -1,  0],
        [ 5,  0,  4, -1],
        [-1, -1, -1,  3],
        [ 7,  3,  6, -1],
        [-1, -1, -1,  5],
        [ 8,  5, -1, -1],
        [-1,  7, -1, -1]]])
```

##### 4. RETR_TREE

这是最后的家伙，Mr.Perfect。它检索所有的轮廓，并创建一个完整的家庭层次结构列表。它甚至告诉我们，谁是爷爷，父亲，儿子，孙子，甚至超越…：）。

比如，我把上面的图片，重写代码cv2.retr_tree，重新排列轮廓按照OpenCV给出的结果与分析。再次，红色字母给出的轮廓数和绿色字母给层次顺序。

以contour-0：它是hierarchy-0。在同一层次contour-7下轮廓。没有以前的轮廓。孩子contour-1。没有父母。所以数组是[ 7，1,1，- 1 ]。以contour-2：它是hierarchy-1。同级别无轮廓。没有以前。孩子contour-2。父母是contour-0。所以数组[ - 1，- 1,2,0 ]。剩下的，试试自己。下面是完整的答案：

```
>>> hierarchy
array([[[ 7, -1,  1, -1],
        [-1, -1,  2,  0],
        [-1, -1,  3,  1],
        [-1, -1,  4,  2],
        [-1, -1,  5,  3],
        [ 6, -1, -1,  4],
        [-1,  5, -1,  4],
        [ 8,  0, -1, -1],
        [-1,  7, -1, -1]]])
```





