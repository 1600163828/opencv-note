
>http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_canny/py_canny.html

#### 本节目标
```
Canny边缘检测的概念
用于opencv的函数: cv2.Canny() cv2.Sobel()
```

#### Theory(原理)

Canny边缘检测是一种比较流行的边缘检测算法。它是由John F. Canny在1986。这是一个多阶段的算法，我们将通过每个阶段。

##### 降噪

由于边缘检测易受图像中的噪声，第一步是去除图像中的噪声和5x5的高斯滤波器。我们已经在前面的章节中看到了这一点。


##### 寻找图像的强度梯度

然后用平滑的图像在水平和垂直方向的Sobel算子在水平方向得到一阶导数滤波（）和垂直方向（）。从这两幅图像，我们可以找到每个像素的边缘梯度和方向如下：

梯度方向总是垂直于边缘。它是圆的四个角之一代表垂直，水平和两个对角线方向。


##### 非最大抑制

在得到梯度幅值和方向后，对图像进行全扫描以去除不构成边缘的任何不想要的像素。对于这一点，在每个像素，像素检查，如果它是在其附近的局部最大的梯度方向。检查下面的图片：

A点在边缘（垂直方向）。梯度方向是正常的边缘。点B和C是在梯度方向。所以A点用B和C检验，看它是否形成一个局部极大值。如果是这样，它被认为是下一个阶段，否则，它被抑制（放在零）。

总之，你得到的结果是一个二进制图像与“瘦边”。


##### 滞后阈值

这个阶段决定所有的边都是边，而不是边。为此，我们需要两阈值minVal和Maxval。强度梯度超过Maxval肯定会边缘低于minVal任何边缘一定是无边，所以丢弃。躺在这两个阈值之间的边缘或非边缘的基础上连接。如果它们被连接到“肯定边缘”像素，它们被认为是边缘的一部分。否则，他们也被丢弃。看下面的图片：

边缘高于Maxval，因此被认为是“肯定的边缘”。虽然边缘C低于Maxval，它是连接到边缘，这样也视为有效的边缘得到了全曲线。但边缘B，虽然是在同一地区，上述minVal，边缘C，它没有连接任何“确定的边缘”，所以被丢弃。所以，我们要选择minVal从而得到正确的结果Maxval是非常重要的。

这个阶段还消除了小像素噪声的假设，边缘是长线。所以我们最终得到的是图像中的强边。


#### OpenCV中的Canny边缘检测

opencv将所有以上功能单一， cv2.Canny(). 我们将看到如何使用它。第一个参数是我们的输入图像。第二个和第三个参数是我们minVal和Maxval分别。第三个参数是aperture_size。它是用于查找图像梯度的Sobel核的大小。默认情况下是3。最后的论点是l2gradient指定寻找梯度方程。如果是真的，它使用上面提到的方程更准确，否则使用这个函数：。默认情况下，它是假的。

```
img = cv2.imread('messi5.jpg',0)
edges = cv2.Canny(img,100,200)
```


#### OpenCV中的Sobel边缘检测

Sobel依然是一种过滤器，只是其是带有方向的. 

```dst = cv2.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])```

前四个是必须的参数：
第一个参数是需要处理的图像；
第二个参数是图像的深度，-1表示采用的是与原图像相同的深度。目标图像的深度必须大于等于原图像的深度；
dx和dy表示的是求导的阶数，0表示这个方向上没有求导，一般为0、1、2。

其后是可选的参数：
ksize是Sobel算子的大小，必须为1、3、5、7。
scale是缩放导数的比例常数，默认情况下没有伸缩系数；
delta是一个可选的增量，将会加到最终的dst中，同样，默认情况下没有额外的值加到dst中；
borderType是判断图像边界的模式。这个参数默认值为cv2.BORDER_DEFAULT。

```
x = cv2.Sobel(image,cv2.CV_16S,1,0)
y = cv2.Sobel(image,cv2.CV_16S,0,1)

#返回uint8类型的图片
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)

dst = cv2.addWeighted(absX,0.5,absY,0.5,0)
```