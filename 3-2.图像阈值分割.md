>http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html

#### 本节目标
```
在本教程中，您将学习简单的阈值，自适应阈值，Otsu’s阈值等
```

#### 1、Simple Thresholding(简单的阀值)

在这里，事情直截了当。如果像素值大于阈值，则指定一个值(可能是白色)，否则它被赋值为另一个值(可能是黑色)。所用的函数是cv2.threshold，她有4个参数
```
第一个参数是源图像,必须是灰度图像
第二个参数是用于分类像素值的阈值
第三个参数是:如果像素值大于（有时小于）阈值，则表示该值
OpenCV提供了不同的阈值风格，它由函数的第四个参数决定
    cv2.THRESH_BINARY
    cv2.THRESH_BINARY_INV
    cv2.THRESH_TRUNC
    cv2.THRESH_TOZERO
    cv2.THRESH_TOZERO_INV
```

获得两个输出。第一个是用稍后解释。第二输出是我们的阈值图像。

示例:
```
img=cv2.imread('123.jpg',0)

ret,img=cv2.threshold(img,100,255,cv2.THRESH_TOZERO_INV)

cv2.imshow('image',img)

cv2.waitKey(0)

cv2.destroyAllWindows()
```

#### 2、Adaptive Thresholding(自适应阈值)

在上一节中，我们使用一个全局值作为阈值。但在不同条件下图像的照明条件不同的情况下，这可能不好。在这种情况下，我们去自适应阈值。在此，该算法计算阈值的一个小区域的图像。因此，我们得到不同的阈值相同的图像的不同区域，它给我们更好的结果，具有不同的照明的图像。

它有三个“特别”的输入参数和一个输出参数。
```
Adaptive Method - 它决定如何计算阈值值。
    cv2.ADAPTIVE_THRESH_MEAN_C - 阈值是邻域的平均值
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C - 阈值是加权值是高斯窗口的邻域值的加权和

Block Size  - 它决定了街区的面积

C - 它只是一个常数减去平均或加权平均计算
```

示例
```
th2=cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2)

th3=cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,11,2)
```

#### 3、Otsu’s Binarization(Otsu二值化)

在第一部分，我告诉你有一个二参数用。它的使用时，Otsu的二值化

在全局阈值，我们使用了任意值的阈值，对不对？那么，我们怎样才能知道我们选择的价值是好还是坏呢？答案是，尝试和错误的方法。但考虑双峰图像（简单地说，双峰图像是一个直方图有两个峰的图像）。对于这个图像，我们可以大致取一个值在中间的峰值作为阈值，对不对？这就是Otsu binarization所做的。因此，简单地说，它自动计算出一个阈值的图像直方图双峰图像。（对于不是双峰的图像，二值化并不准确。）

为此，cv2.threshold使用一个额外的标识，cv2.THRESH_OTSU，对于阈值，只通过零，然后该算法找到最佳阈值并返回你的第二输出。如果Otsu的阈值是不能用的，你用相同的阈值

检查下面的例子。输入图像是一个嘈杂的图像。在第一种情况下，我应用全局阈值为127的值。在第二种情况下，我直接应用Otsu阈值。在第三的情况下，我与一个5x5高斯内核过滤图像去除噪声，然后利用Otsu阈值。看噪声滤波如何改善结果。

```
img = cv2.imread('123.jpg',0)

# global thresholding
ret1,th1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)

# Otsu's thresholding
ret2,th2 = cv2.threshold(img,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)

# Otsu's thresholding after Gaussian filtering
blur = cv2.GaussianBlur(img,(5,5),0)
ret3,th3 = cv2.threshold(blur,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)

# plot all the images and their histograms
images = [img, 0, th1,
          img, 0, th2,
          blur, 0, th3]
titles = ['Original Noisy Image','Histogram','Global Thresholding (v=127)',
          'Original Noisy Image','Histogram',"Otsu's Thresholding",
          'Gaussian filtered Image','Histogram',"Otsu's Thresholding"]

for i in xrange(3):
    plt.subplot(3,3,i*3+1),plt.imshow(images[i*3],'gray')
    plt.title(titles[i*3]), plt.xticks([]), plt.yticks([])
    plt.subplot(3,3,i*3+2),plt.hist(images[i*3].ravel(),256)
    plt.title(titles[i*3+1]), plt.xticks([]), plt.yticks([])
    plt.subplot(3,3,i*3+3),plt.imshow(images[i*3+2],'gray')
    plt.title(titles[i*3+2]), plt.xticks([]), plt.yticks([])
plt.show()
```
